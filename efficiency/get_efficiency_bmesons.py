'''
Script for the computation of the B0 meson efficiency
run: python get_efficiency_b0.py config_file_name.yml
'''

import sys
sys.path.append('utils') # pylint: disable=wrong-import-position
import ctypes
import argparse
import ROOT
import pandas as pd
import numpy as np
import yaml
from utils.df_utils import read_parquet_in_batches
from utils.analysis_utils import evaluate_efficiency_from_histos
from utils.style_formatter import root_colors_from_matplotlib_colormap
# pylint: disable=no-member

def draw_efficiency_figure(particle, h_eff, h_eff_trigger, h_acc, out_file_name_pdf): # pylint: disable=too-many-statements
    """
    Draw the efficiency and acceptance histograms.

    Args:
        h_eff (TH1F): The efficiency histogram.
        h_eff_trigger (TH1F): The efficiency histogram before the BDT.
        h_acc (TH1F): The acceptance histogram.
        out_file_name_pdf (str): The name of the output PDF file.

    Returns:
        None
    """

    # Set style
    ROOT.gStyle.SetOptStat(0)
    ROOT.gStyle.SetPadLeftMargin(0.14)
    ROOT.gStyle.SetPadBottomMargin(0.12)
    ROOT.gStyle.SetPadTopMargin(0.05)
    ROOT.gStyle.SetPadRightMargin(0.05)
    ROOT.gStyle.SetPadTickX(1)
    ROOT.gStyle.SetPadTickY(1)

    colors, _ = root_colors_from_matplotlib_colormap("tab10")

    h_eff.SetMarkerStyle(ROOT.kFullCircle)
    h_eff.SetMarkerColor(colors[0])
    h_eff.SetMarkerSize(2)
    h_eff.SetLineColor(colors[0])
    h_eff.SetLineWidth(2)

    h_eff_trigger.SetMarkerStyle(ROOT.kFullSquare)
    h_eff_trigger.SetMarkerColor(colors[1])
    h_eff_trigger.SetMarkerSize(2)
    h_eff_trigger.SetLineColor(colors[1])
    h_eff_trigger.SetLineWidth(2)
    h_eff_trigger.SetLineStyle(2)

    h_acc.SetMarkerStyle(ROOT.kFullDiamond)
    h_acc.SetMarkerColor(colors[2])
    h_acc.SetMarkerSize(2.5)
    h_acc.SetLineColor(colors[2])
    h_acc.SetLineWidth(2)
    h_acc.SetLineStyle(7)

    leg = ROOT.TLegend(0.5, 0.15, 0.8, 0.3)
    leg.SetTextSize(0.045)
    leg.SetFillStyle(0)
    leg.SetBorderSize(0)
    leg.AddEntry(h_acc, "Acceptance", "pl")
    leg.AddEntry(h_eff_trigger, "Acc. #times #varepsilon_{trigger}", "pl")
    leg.AddEntry(h_eff, "Acc. #times #varepsilon", "pl")

    c_eff = ROOT.TCanvas('c_eff', '', 800, 800)
    c_eff.SetLogy()
    h_frame = c_eff.DrawFrame(h_eff.GetBinLowEdge(1), 1.e-4, h_eff.GetBinLowEdge(h_eff.GetNbinsX()+1), 10.,
                ';#it{p}_{T} (GeV/#it{c});Acceptance #times Efficiency;')
    h_frame.GetXaxis().SetTitleOffset(1.2)
    h_frame.GetYaxis().SetTitleOffset(1.5)
    h_frame.GetYaxis().SetTitleSize(0.04)
    h_frame.GetYaxis().SetLabelSize(0.04)
    h_frame.GetXaxis().SetTitleSize(0.04)
    h_frame.GetXaxis().SetLabelSize(0.04)
    h_eff_trigger.Draw('][ hist same')
    h_eff_trigger.DrawClone('pe X0 same')
    h_eff.Draw('][ hist same')
    h_eff.DrawClone('pe X0 same')
    h_acc.Draw('][ hist same')
    h_acc.DrawClone('pe X0 same')
    leg.Draw()

    # Add the text
    decay_channel = ''
    if particle == "Bplus":
        decay_channel = 'B^{+}#rightarrow#bar{D}^{#font[122]{0}}#pi^{+}\
            #rightarrow #pi^{#font[122]{-}}K^{+}#pi^{+}'
    if particle == "B0":
        decay_channel = 'B^{0}#rightarrow D^{#font[122]{-}}#pi^{+}\
            #rightarrow #pi^{#font[122]{-}}K^{+}#pi^{#font[122]{-}}#pi^{+}'

    text_decay = ROOT.TLatex(0.51, 0.36, decay_channel)
    text_decay.SetNDC()
    text_decay.SetTextSize(0.04)
    text_decay.SetTextFont(42)
    text_decay.Draw()

    text_conj = ROOT.TLatex(0.51, 0.31, 'and charge conjugate')
    text_conj.SetNDC()
    text_conj.SetTextSize(0.04)
    text_conj.SetTextFont(42)
    text_conj.Draw()

    text_alice = ROOT.TLatex(0.18, 0.88, 'Work in Progress')
    text_alice.SetNDC()
    text_alice.SetTextSize(0.06)
    text_alice.SetTextFont(42)
    text_alice.Draw()

    text_pp = ROOT.TLatex(0.18, 0.83, 'pp collisions, #sqrt{#it{s}} = 13.6 TeV')
    text_pp.SetNDC()
    text_pp.SetTextSize(0.04)
    text_pp.SetTextFont(42)
    text_pp.Draw()

    text_rapidity = ROOT.TLatex(0.18, 0.78, '|y| < 0.5')
    text_rapidity.SetNDC()
    text_rapidity.SetTextSize(0.04)
    text_rapidity.SetTextFont(42)
    text_rapidity.Draw()

    c_eff.SaveAs(out_file_name_pdf)

def compute_efficiency(config_file_name): # pylint: disable=too-many-statements
    """
    Compute the efficiency of a B meson based on the given configuration and cut set.

    Args:
        config_file_name (str): The file name of the configuration file.

    Returns:
        None
    """

    with open(config_file_name, 'r', encoding="utf-8") as yml_config_file:
        config = yaml.safe_load(yml_config_file)

    with open(config['cutset_file_name'], 'r', encoding="utf-8") as yml_cut_set_file:
        cut_set = yaml.safe_load(yml_cut_set_file)

    particle = config["particle"]
    pt_mins = cut_set['pt']['mins']
    pt_maxs = cut_set['pt']['maxs']
    pt_lims = list(pt_mins)
    n_pt_bins = len(pt_mins)
    pt_lims.append(pt_maxs[-1])

    h_reco_integrated = ROOT.TH1F(
        'h_reco_integrated', ';#it{p}_{T} (GeV/#it{c});Reconstructed',
        n_pt_bins, np.asarray(pt_lims, 'd')
    )
    h_reco_trigger_integrated = ROOT.TH1F(
        'h_reco_trigger_integrated', ';#it{p}_{T} (GeV/#it{c});Reconstructed before BDT',
        n_pt_bins, np.asarray(pt_lims, 'd')
    )
    h_gen_integrated = ROOT.TH1F(
        'h_gen_integrated', ';#it{p}_{T} (GeV/#it{c});Generated',
        n_pt_bins, np.asarray(pt_lims, 'd')
    )
    h_gen_in_acc_integrated = ROOT.TH1F(
        'h_gen_in_acc_integrated', ';#it{p}_{T} (GeV/#it{c});Generated in acceptance',
        n_pt_bins, np.asarray(pt_lims, 'd')
    )

    # Get the generated and reconstructed particles
    for i_file, in_file_name in enumerate(config['gen']['file_names']):
        in_file = ROOT.TFile.Open(in_file_name)
        h_sparse_gen = in_file.Get(config['gen']['sparse_name'])
        h_sparse_gen_in_acc = in_file.Get(config['gen']['sparse_name_acc'])
        if i_file == 0:
            h_gen = h_sparse_gen.Projection(config['gen']['pt_axis'])
            h_gen.SetDirectory(0)
            h_gen_in_acc = h_sparse_gen_in_acc.Projection(config['gen']['pt_axis'])
            h_gen_in_acc.SetDirectory(0)
        else:
            h_gen.Add(h_sparse_gen.Projection(config['gen']['pt_axis']))
            h_gen_in_acc.Add(h_sparse_gen_in_acc.Projection(config['gen']['pt_axis']))
        in_file.Close()

    h_gen.SetName('h_gen')
    h_gen_in_acc.SetName('h_gen_in_acc')
    h_reco = h_gen.Clone('h_reco')
    h_reco.Reset()
    h_reco_trigger = h_reco.Clone('h_reco_trigger')
    h_reco_trigger.Reset()


    for i_pt, (pt_min, pt_max) in enumerate(zip(pt_mins, pt_maxs)):

        # Apply the cuts on the reconstructed particles
        require_signal = "(fFlagMcMatchRec == -1 or fFlagMcMatchRec == 1)"
        df_reco = pd.concat(
            [read_parquet_in_batches(parquet, f"{pt_min} < fPt < {pt_max} and {require_signal}")
             for parquet in config['reco_file_names']])

        for pt in df_reco['fPt']:
            h_reco_trigger.Fill(pt)

        sel_to_apply = ''
        for cut_var in cut_set:
            if cut_var in ('pt', 'M'):
                continue
            sel_to_apply += f" {cut_set[cut_var]['mins'][i_pt]} < {cut_var} < {cut_set[cut_var]['maxs'][i_pt]} and"
        sel_to_apply = sel_to_apply[:-3] # Remove the last 'and'

        df_reco = df_reco.query(sel_to_apply)
        for pt in df_reco['fPt']:
            h_reco.Fill(pt)

        # Get the number of generated and reconstructed particles in the given pt range
        n_reco_unc, n_reco_trigger_unc, n_gen_unc, n_gen_in_acc_unc = (ctypes.c_double() for _ in range(4))
        n_reco_trigger = h_reco_trigger.IntegralAndError(
            h_reco_trigger.FindBin(pt_min), h_reco_trigger.FindBin(pt_max)-1, n_reco_trigger_unc
        )
        n_reco = h_reco.IntegralAndError(h_reco.FindBin(pt_min), h_reco.FindBin(pt_max)-1, n_reco_unc)
        n_gen = h_gen.IntegralAndError(h_gen.FindBin(pt_min), h_gen.FindBin(pt_max)-1, n_gen_unc)
        n_gen_in_acc = h_gen_in_acc.IntegralAndError(
            h_gen_in_acc.FindBin(pt_min), h_gen_in_acc.FindBin(pt_max)-1, n_gen_in_acc_unc
        )

        h_reco_integrated.SetBinContent(i_pt+1, n_reco)
        h_reco_integrated.SetBinError(i_pt+1, n_reco_unc.value)
        h_reco_trigger_integrated.SetBinContent(i_pt+1, n_reco_trigger)
        h_reco_trigger_integrated.SetBinError(i_pt+1, n_reco_trigger_unc.value)
        h_gen_integrated.SetBinContent(i_pt+1, n_gen)
        h_gen_integrated.SetBinError(i_pt+1, n_gen_unc.value)
        h_gen_in_acc_integrated.SetBinContent(i_pt+1, n_gen_in_acc)
        h_gen_in_acc_integrated.SetBinError(i_pt+1, n_gen_in_acc_unc.value)

    # Compute the efficiency and acceptance in the given pt ranges
    h_eff = evaluate_efficiency_from_histos(h_gen_integrated, h_reco_integrated)
    h_eff.SetName('h_eff')

    h_eff_trigger = evaluate_efficiency_from_histos(h_gen_integrated, h_reco_trigger_integrated)
    h_eff_trigger.SetName('h_eff_trigger')

    h_acc = evaluate_efficiency_from_histos(h_gen_integrated, h_gen_in_acc_integrated)
    h_acc.SetName('h_acc')

    # Compute the efficiency in pt bins used for the generated particles
    h_eff_fine_bins = evaluate_efficiency_from_histos(h_gen, h_reco)
    h_eff_fine_bins.SetName('h_eff_fine_bins')

    h_eff_trigger_fine_bins = evaluate_efficiency_from_histos(h_gen_in_acc, h_reco_trigger)
    h_eff_trigger_fine_bins.SetName('h_eff_trigger_fine_bins')

    h_acc_fine_bins = evaluate_efficiency_from_histos(h_gen, h_gen_in_acc)
    h_acc_fine_bins.SetName('h_acc_fine_bins')

    out_file = ROOT.TFile(config['output_file_name'], 'recreate')
    h_eff.Write()
    h_eff_fine_bins.Write()
    h_eff_trigger.Write()
    h_eff_trigger_fine_bins.Write()
    h_acc.Write()
    h_acc_fine_bins.Write()
    h_gen.Write()
    h_reco.Write()
    h_reco_trigger.Write()
    h_gen_in_acc.Write()
    h_gen_integrated.Write()
    h_gen_in_acc_integrated.Write()
    h_reco_integrated.Write()
    h_reco_trigger_integrated.Write()
    out_file.Close()

    out_file_name_pdf = config['output_file_name'].replace('.root', '.pdf')
    draw_efficiency_figure(particle, h_eff, h_eff_trigger, h_acc, out_file_name_pdf)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Arguments')
    parser.add_argument('config_file_name', metavar='text', default='config_eff.yaml')
    args = parser.parse_args()

    compute_efficiency(args.config_file_name)
